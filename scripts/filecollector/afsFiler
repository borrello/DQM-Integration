#!/usr/bin/env python
import os, datetime, time,  sys, shutil, glob, re, subprocess as sp,tempfile
from commonAnTS import *
if len(sys.argv)<=1 or not os.path.exists(sys.argv[1]):
  print "No valid configuration file"
  sys.exit()
execfile(sys.argv[1])
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
#####         MAIN PROGRAM         ######
while True:
  AFS_FILE_LIST={}
  AFSnewestMTime=0
  for directory, subdirs, files in os.walk(AFS_BASE_DIR):
    for f in files:
      if f[0] == ".":
        continue
      fullFileName="%s/%s" % (directory,f)
      fileSize=os.stat(fullFileName).st_size
      fileMTime=os.stat(fullFileName).st_mtime
      if AFSnewestMTime < fileMTime:
        AFSnewestMTime = fileMTime
      if not "latest" in f:
        AFS_FILE_LIST.setdefault(fullFileName,[fileSize,fileMTime])
        
  FILE_LIST={} 
  for directory, subdirs, files in os.walk(BASE_DIRECTORY):
    filesToConsider=[f for f in files if os.path.getmtime("/".join([directory,f]))>=AFSnewestMTime ]
    filesToConsider.sort(cmp=lambda x,y:cmp(os.path.getmtime("/".join([directory,x])),os.path.getmtime("/".join([directory,y]))),
                    reverse=True)
    DEBUG and debugMsg(0,"Found %d new files in directory %s" % (len(filesToConsider),directory))      
    for f in filesToConsider:
      fullFileName="%s/%s" % (directory,f)
      fileSize=os.stat(fullFileName).st_size
      fileMTime=os.stat(fullFileName).st_mtime
      if fileMTime < AFSnewestMTime:
        break
      FILE_LIST.setdefault(fullFileName,[fileSize,fileMTime])
      DEBUG and debugMsg(0,"Added file %s with timestamp %d and size %d to FILE_LIST" % (fullFileName,fileSize,fileMTime))
  #make final fie list that's going into AFS 
  FINAL_LIST={}
  quota=0
  quotaFilled=False
  for f in sorted(FILE_LIST,key=lambda x: FILE_LIST[x][1],reverse=True):
    if quota+FILE_LIST[f][0] > QUOTA:
       quotaFilled=True
       DEBUG and debugMsg(0,"Quota has been reached")
       break
    quota=quota+FILE_LIST[f][0]
    destFile=f.replace(BASE_DIRECTORY,AFS_BASE_DIR)
    FINAL_LIST.setdefault(f,destFile) 
    DEBUG and debugMsg(0,"Added file %s with destination %s to the FINAL_LIST" % (f,destFile))
  #see if any of the CURRENT AFS files stays
  if not quotaFilled:
    for f in sorted(AFS_FILE_LIST,key=lambda x: AFS_FILE_LIST[x][1],reverse=True):
      if quota+AFS_FILE_LIST[f][0] > QUOTA:
         quotaFilled=True
         DEBUG and debugMsg(0,"Quota has been reached")
         break
      quota=quota+AFS_FILE_LIST[f][0]
      FINAL_LIST.setdefault(f,f) 
      DEBUG and debugMsg(0,"Added file %s from AFS to the FINAL_LIST" % f  )
  #find files to be deleted
  DELETE_LIST=[f for f in sorted(AFS_FILE_LIST,key=lambda x: AFS_FILE_LIST[x][1]) if f not in FINAL_LIST.keys() and len([ex for ex in EXCLUDED if ex in f])==0]
  DEBUG and debugMsg(0,"Found %d files in AFS to delete" % len(DELETE_LIST))
  #delete files
  for f in DELETE_LIST:
    os.remove(f)
    DEBUG and debugMsg(0,"File %s hass been deleted " % f)
    try:
      os.removedirs(os.path.dirname(f))
      DEBUG and debugMsg(0,"Deleted directory %s " % os.path.dirname(f))
    except:
      pass
  
  #copy files
  for orig,dest in FINAL_LIST.items():
    if orig!=dest:
      if not os.path.exists(os.path.dirname(dest)):
        os.makedirs(os.path.dirname(dest))
        DEBUG and debugMsg(0,"created directory directory %s " % os.path.dirname(dest))
      shutil.copy2(orig,dest)
      debugMsg(0,"Files %s succesfuly copyed to %s " % (orig,dest))
  
  DEBUG and debugMsg(0,"Finished processing list going to sleep for: '%d' seconds" % AFS_FILER_WAIT_TIME)
  time.sleep(AFS_FILER_WAIT_TIME)
